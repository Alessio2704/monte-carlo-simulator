import json
from lark import Lark, Transformer, v_args

# Read the grammar file
with open("valuascript.lark", "r") as f:
    valuascript_grammar = f.read()


@v_args(inline=True)  # Makes the transformer methods receive nodes directly
class ValuaScriptTransformer(Transformer):
    """
    This class walks the parse tree generated by Lark and transforms it
    into a Python dictionary that matches the structure of our JSON recipe.
    """

    def scalar_assignment(self, var_name, value):
        """
        Handles the 'scalar_assignment' rule from the grammar.
        'var_name' and 'value' are the processed child nodes.
        """
        # The 'value' token is a string, so we convert it to a float
        numeric_value = float(value)

        # We return a tuple containing the variable name and its data dictionary.
        # This is a convenient intermediate format.
        return (str(var_name), {"type": "fixed", "value": numeric_value})

    def start(self, *assignments):
        """
        Handles the top-level 'start' rule. It receives all the processed
        assignment tuples from its children.
        """
        # This is the root structure of our JSON recipe
        recipe = {"simulation_config": {}, "inputs": {}, "operations": [], "output_variable": ""}

        # Populate the "inputs" dictionary from the assignment tuples
        recipe["inputs"] = dict(assignments)

        return recipe

    # Lark automatically handles imported terminals like SIGNED_NUMBER and CNAME.
    # We don't need to define methods for them unless we want to transform their raw values.
    # In our case, the default behavior is fine.


def main():
    """
    The main function to drive the transpilation.
    """
    # 1. Create the Lark parser instance
    parser = Lark(valuascript_grammar, start="start")

    # 2. Read the example ValuaScript file
    with open("example.valuascript", "r") as f:
        script_content = f.read()

    # 3. Parse the script to get an Abstract Syntax Tree (AST)
    try:
        parse_tree = parser.parse(script_content)
        # print("--- Parse Tree ---")
        # print(parse_tree.pretty()) # Uncomment to see the raw tree
    except Exception as e:
        print(f"Error parsing script: {e}")
        return

    # 4. Create an instance of our transformer
    transformer = ValuaScriptTransformer()

    # 5. Transform the tree to get our final Python dictionary (recipe)
    recipe_dict = transformer.transform(parse_tree)

    # 6. Convert the dictionary to a JSON string and print it
    recipe_json = json.dumps(recipe_dict, indent=2)

    print("--- Generated JSON Recipe ---")
    print(recipe_json)


if __name__ == "__main__":
    main()
